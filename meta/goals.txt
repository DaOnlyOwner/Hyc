TODO:
- pointer types: a# -> pointer symbol = # (no ugly lexer hack: https://en.wikipedia.org/wiki/Lexer_hack) -> Better idea: keep a*, but cast with e.g. (1 as float), keyword "as"
- Generics like List<List<int>>
  -> functions: u64 fn<T>();
- No definition of member functions. 
  -> if you want to call something like this: foo->bar();
  -> then the declaration should look like this:
  struct foo
  {
  }
  void bar(foo* this); // This is basically like an extension method 
  then:
  f->bar() 
  becomes desugared: bar(&f);
  char* to_str(int);
  -> 5.to_str() ---> calls to_str(5);
- constructors,destructors.
  there are no constructors, but something that looks like this:
  int a : init() -> desugared: int a; a.init();
  int a := b; OR a:=b (possible to leave out type)-> desugared: int a; a=b;
  int a :# b; OR a:#b -> int a; a#b; <- move operator
  idiomatic heap allocation: int* a : new()->init();
  operators can be deleted etc.
  special operator % <-- cannot be generic, can be overloaded.
  called when object leaves the scope
  overloading: void operator%(foo* a)
- operators:
  int operator+(foo* f, bar* b){}
  -> int a = f + b;	
- casts
  3 as int;
- const 
- moving and copying:
  copying looks like this
  a := b; <- uses the default copy operator
  copy operator can be overloaded 
  foo* operator=(foo* a, foo* b){}
  moving looks like this:
  a :# b; foo a :# b; is default defined
  overloaded:
  foo* operator#(foo* a, foo* b){}
  
- global type inference inside functions;
- unions: 
  a := (int?uint)::new(-1);
  switch_type a
  {
    case int: break;
    case uint: break;
  }
- default value init in structs. MAYBE
- unions:
union A
{
   int a;
   float b;
}
typesafe:
A foo;
foo.a = 4; 
foo.type == 0 // type is readonly and is of type int
foo.b = 4.0;
foo.type == 1
match(foo)
{
case int as i // i has the same address as foo.a.
{} // Note the braces, they are needed here, no break
case float as f // f has the same address as foo.f
{}
}
void a(int* i);
void a(float* f);
foo..a(); 
Desugared (but don't actually desugare it in code):
match(foo)
{
case int as i // i has the same address as foo.a.
{
  i.a();
} // Note the braces, they are needed here, no break
case float as f // f has the same address as foo.f
{
  f.a();
}
}
foo->>a(); for pointer
However foo.a() calls a(foo*); 

- function pointers: fptr(args type;return_type)
- array decl: int[5] a;
- desugar typedefs before typechecking!
- enums
- initialization list:
int[3] a {0,1,2}; 
f(int[3]{0,1,2});
A a {.first{"" },.second{""}};
void a(int a{0},int b)
- Implementation note: Save a unique pointer to BaseType in Scopes and let Type struct have a pointer to BaseType, so we don't need to compare strings.
- Add foreach loop later
- infer generic type parameters at function call.
- default is moving when calling a function e.g. a(b); b is moved into the argument
  -> copying: a(=b);


Avoided, but want to implement:
- Structs, union def inside structs, unions

Implementation order:
- implement parsing of structs,functions,generics,expressions,statements(also switch, match),namespaces,operators,unions,type deduction for function generics
- quality of life updates: incremental
  -> enums
  -> initialization lists
  -> try catch
- import statements
- Implement meta programming
- Implement a standard library