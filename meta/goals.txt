TODO:
- pointer types: a# -> pointer symbol = # (no ugly lexer hack: https://en.wikipedia.org/wiki/Lexer_hack) -> Better idea: keep a*, but cast with e.g. (1 as float), keyword "as"
- Generics like List<List<int>>
  -> functions: u64 fn<T>();
- No definition of member functions. 
  -> if you want to call something like this: foo->bar();
  -> then the declaration should look like this:
  struct foo
  {
  }
  void bar(foo* this); // This is basically like an extension method 
  then:
  f->bar() 
  becomes desugared: bar(&f);
  char* to_str(int);
  -> 5.to_str() ---> calls to_str(5);
- constructors,destructors.
  there are no constructors, but something that looks like this:
  int a : init() -> desugared: int a; a.init();
  int a := b; OR a:=b (possible to leave out type)-> desugared: int a; a=b;
  int a :# b; OR a:#b -> int a; a#b; <- move operator
  idiomatic heap allocation: int* a : new()->init();
  operators can be deleted etc.
  special operator % <-- cannot be generic, can be overloaded.
  called when object leaves the scope
  overloading: void operator%(foo* a)
- operators:
  int operator+(foo* f, bar* b){}
  -> int a = f + b;	
- casts
  3 as int;
- const 
- moving and copying:
  copying looks like this
  a := b; <- uses the default copy operator
  copy operator can be overloaded 
  foo* operator=(foo* a, foo* b){}
  moving looks like this:
  a :# b; foo a :# b; is default defined
  overloaded:
  foo* operator#(foo* a, foo* b){}
  
- default value init in structs. MAYBE
- unions:
union A
{
   int a:3; // declare a field 'a' with type 'int' and tagged value 3
   float b:2;
   c:1; // untyped 
   d:0;
}
typesafe:
A foo;
foo.a = 4; // makes a active
foo.b = 4.0; // makes b active
foo!!c // makes c active, but doesn't initialize memory 
foo??c // checks if c is active, returns true if that is the case, else false.
if(foo as int == 3) {foo??a==true;} <-- Can cast union to int type which returns the tagged value.
match(foo)
{
case a 
{} // Note the braces, they are needed here, no break
case b
{}
case c
{}
}

match() is an expression!

^--- TODO: Rewrite the parser so that it accepts an identifier not a type in "case [...]"

- function pointers: fptr(args type;return_type)
- array decl: int[5] a;
- desugar typedefs before typechecking!
- initialization list:
int[3] a {0,1,2}; 
f(int[3]{0,1,2});
A a {.first{"" },.second{""}};
- Implementation note: Save a unique pointer to BaseType in Scopes and let Type struct have a pointer to BaseType, so we don't need to compare strings. DONE
- Add foreach loop later
- infer generic type parameters at function call.
- default is moving when calling a function e.g. a(b); b is moved into the argument
  -> copying: a(=b);
- disallow parameters like int[4] in parser
- operator as -> need special parsing and handling in the semantic checking.
- disallow overloading of operators with atomic types.

Avoided, but want to implement:
- Structs, union def inside structs, unions, namespaces

Implementation order:
- implement parsing of structs,functions,generics,expressions,statements(also switch, match),namespaces,operators,unions,type deduction for function generics
- quality of life updates: incremental
  -> enums
  -> initialization lists
  -> try catch
- import statements
- Implement meta programming
- Implement a standard library